# frozen_string_literal: true

require_relative "../../logger"
require_relative "../parsers/document_parser"
require_relative "../generators/wbs_generator"
require_relative "../generators/gantt_generator"
require_relative "../mappers/persona_mapper"

module Aidp
  module Planning
    module Builders
      # Orchestrates generation of complete project plan
      # Coordinates all planning components (parsing, generating, mapping)
      class ProjectPlanBuilder
        def initialize(
          ai_decision_engine:,
          config: nil,
          document_parser: nil,
          wbs_generator: nil,
          gantt_generator: nil,
          persona_mapper: nil
        )
          @ai_decision_engine = ai_decision_engine
          @config = config || Aidp::Config.waterfall_config
          @document_parser = document_parser || Parsers::DocumentParser.new(ai_decision_engine: ai_decision_engine)
          @wbs_generator = wbs_generator || Generators::WBSGenerator.new(config: @config)
          @gantt_generator = gantt_generator || Generators::GanttGenerator.new(config: @config)
          @persona_mapper = persona_mapper || Mappers::PersonaMapper.new(ai_decision_engine: ai_decision_engine, config: @config)
        end

        # Build project plan from existing documentation (ingestion path)
        # @param docs_path [String] Path to existing documentation
        # @return [Hash] Complete project plan
        def build_from_ingestion(docs_path)
          Aidp.log_debug("project_plan_builder", "build_from_ingestion", path: docs_path)

          # Parse existing docs
          parsed_docs = @document_parser.parse_directory(docs_path)
          Aidp.log_debug("project_plan_builder", "parsed_docs", count: parsed_docs.size)

          # Extract PRD and design docs
          prd = parsed_docs.find { |d| d[:type] == :prd }
          tech_design = parsed_docs.find { |d| d[:type] == :design }

          # Generate plan components
          build_plan_components(prd, tech_design)
        end

        # Build project plan from scratch (generation path)
        # @param requirements [Hash] User-provided requirements
        # @return [Hash] Complete project plan
        def build_from_scratch(requirements)
          Aidp.log_debug("project_plan_builder", "build_from_scratch")

          # In production, this would use AI to generate PRD and design docs
          # For now, we'll create minimal structure from requirements
          prd = structure_requirements_as_prd(requirements)
          tech_design = nil # Will be generated by AI templates

          build_plan_components(prd, tech_design)
        end

        # Assemble complete project plan document
        # @param components [Hash] All plan components
        # @return [String] Complete PROJECT_PLAN.md content
        def assemble_project_plan(components)
          Aidp.log_debug("project_plan_builder", "assemble_project_plan")

          output = ["# Project Plan", ""]
          output << "Generated: #{Time.now.iso8601}"
          output << ""

          # Executive Summary
          output << "## Executive Summary"
          output << ""
          output << "This document provides a comprehensive project plan including:"
          output << "- Work Breakdown Structure (WBS)"
          output << "- Gantt Chart with Critical Path"
          output << "- Task Dependencies and Milestones"
          output << "- Persona/Agent Assignments"
          output << ""

          # WBS Section
          output << "## Work Breakdown Structure"
          output << ""
          output << components[:wbs_markdown]
          output << ""

          # Gantt Chart Section
          output << "## Timeline and Gantt Chart"
          output << ""
          output << "```mermaid"
          output << components[:gantt_mermaid]
          output << "```"
          output << ""

          # Critical Path
          output << "## Critical Path"
          output << ""
          output << "The following tasks form the critical path (longest sequence):"
          output << ""
          components[:critical_path].each_with_index do |task_id, idx|
            output << "#{idx + 1}. #{task_id}"
          end
          output << ""

          # Persona Assignments
          output << "## Persona Assignments"
          output << ""
          output << "Tasks are assigned to the following personas:"
          output << ""
          persona_summary = summarize_persona_assignments(components[:persona_assignments])
          output << persona_summary
          output << ""

          # Metadata
          output << "## Metadata"
          output << ""
          output << "- **Total Phases:** #{components[:wbs][:metadata][:phase_count]}"
          output << "- **Total Tasks:** #{components[:wbs][:metadata][:total_tasks]}"
          output << "- **Critical Path Length:** #{components[:gantt][:metadata][:critical_path_length]} tasks"
          output << "- **Personas Used:** #{components[:persona_assignments][:metadata][:personas_used].size}"
          output << ""

          output.join("\n")
        end

        private

        def build_plan_components(prd, tech_design)
          # Generate WBS
          wbs = @wbs_generator.generate(prd: prd, tech_design: tech_design)
          wbs_markdown = @wbs_generator.format_as_markdown(wbs)

          # Generate Gantt chart
          gantt = @gantt_generator.generate(wbs: wbs)

          # Extract tasks for persona assignment
          tasks = gantt[:tasks]

          # Assign personas
          persona_assignments = @persona_mapper.assign_personas(tasks)

          {
            prd: prd,
            tech_design: tech_design,
            wbs: wbs,
            wbs_markdown: wbs_markdown,
            gantt: gantt,
            gantt_mermaid: gantt[:mermaid],
            critical_path: gantt[:critical_path],
            persona_assignments: persona_assignments
          }
        end

        def structure_requirements_as_prd(requirements)
          {
            type: :prd,
            sections: {
              "problem_statement" => requirements[:problem] || "Problem to solve",
              "goals" => requirements[:goals] || "Project goals",
              "success_criteria" => requirements[:success_criteria] || "Success metrics"
            },
            raw_content: requirements.to_s
          }
        end

        def summarize_persona_assignments(assignments)
          # Group by persona
          by_persona = {}
          assignments[:assignments].each do |task_id, assignment|
            persona = assignment[:persona]
            by_persona[persona] ||= []
            by_persona[persona] << assignment[:task]
          end

          # Format summary
          output = []
          by_persona.each do |persona, tasks|
            output << "### #{persona} (#{tasks.size} tasks)"
            output << ""
            tasks.each do |task|
              output << "- #{task}"
            end
            output << ""
          end

          output.join("\n")
        end
      end
    end
  end
end
