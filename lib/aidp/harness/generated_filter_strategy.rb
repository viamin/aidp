# frozen_string_literal: true

require_relative "filter_strategy"
require_relative "filter_definition"

module Aidp
  module Harness
    # Deterministic filter strategy using AI-generated patterns
    #
    # This strategy applies a FilterDefinition at runtime without any AI calls.
    # The patterns were generated by AIFilterFactory during configuration.
    #
    # @example Usage
    #   definition = FilterDefinition.from_hash(config[:filter_definitions][:pytest])
    #   strategy = GeneratedFilterStrategy.new(definition)
    #   filtered = strategy.filter(raw_output, filter_instance)
    #
    # @see FilterDefinition for the pattern specification
    # @see AIFilterFactory for how definitions are generated
    class GeneratedFilterStrategy < FilterStrategy
      attr_reader :definition

      # Initialize with a filter definition
      #
      # @param definition [FilterDefinition] The AI-generated filter definition
      def initialize(definition)
        @definition = definition
      end

      # Filter output using the definition's patterns
      #
      # @param output [String] Raw output to filter
      # @param filter_instance [OutputFilter] Filter instance with mode and config
      # @return [String] Filtered output
      def filter(output, filter_instance)
        return output if output.nil? || output.empty?

        case filter_instance.mode
        when :failures_only
          extract_failures_only(output)
        when :minimal
          extract_minimal(output)
        else
          output
        end
      end

      private

      # Extract failures and summary for failures_only mode
      def extract_failures_only(output)
        lines = output.lines
        parts = []

        # Extract summary lines
        summary_lines = extract_summary_lines(lines)
        if summary_lines.any?
          parts << "#{@definition.tool_name} Summary:"
          parts.concat(summary_lines.map(&:strip))
          parts << ""
        end

        # Extract failure section if markers defined
        if @definition.has_failure_section?
          failure_content = extract_section(lines,
            @definition.failure_section_start,
            @definition.failure_section_end)
          if failure_content.any?
            parts << "Failures:"
            parts.concat(failure_content)
            parts << ""
          end
        end

        # Extract error section if different from failures
        if @definition.has_error_section?
          error_content = extract_section(lines,
            @definition.error_section_start,
            @definition.error_section_end)
          if error_content.any?
            parts << "Errors:"
            parts.concat(error_content)
            parts << ""
          end
        end

        # If no section markers are defined, extract lines with error patterns
        # This handles tools that don't have structured failure sections
        unless @definition.has_failure_section? || @definition.has_error_section?
          error_lines = extract_error_lines(lines)
          if error_lines.any?
            parts << "Issues:"
            parts.concat(error_lines)
            parts << ""
          end
        end

        result = parts.join("\n")
        result.empty? ? output : result
      end

      # Extract minimal information (summary + locations only)
      def extract_minimal(output)
        lines = output.lines
        parts = []

        # Extract summary
        summary_lines = extract_summary_lines(lines)
        parts.concat(summary_lines.map(&:strip))

        # Extract all file locations
        locations = extract_all_locations(lines)
        if locations.any?
          parts << ""
          parts << "Locations:"
          parts.concat(locations.uniq.map { |loc| "  #{loc}" })
        end

        parts.join("\n")
      end

      # Extract lines matching summary patterns
      def extract_summary_lines(lines)
        lines.select { |line| @definition.summary_line?(line) }
      end

      # Extract content between section markers
      def extract_section(lines, start_pattern, end_pattern)
        return [] unless start_pattern

        content = []
        in_section = false

        lines.each do |line|
          if !in_section && line.match?(start_pattern)
            in_section = true
            content << line unless @definition.noise_line?(line)
            next
          end

          if in_section
            # Check for section end
            if end_pattern && line.match?(end_pattern)
              in_section = false
              next
            end

            # Skip noise lines but keep important ones
            if @definition.important_line?(line) || !@definition.noise_line?(line)
              content << line
            end
          end
        end

        content.map(&:rstrip)
      end

      # Extract lines with error patterns (when no sections defined)
      def extract_error_lines(lines)
        result = []
        context_buffer = []
        context_lines = @definition.context_lines

        lines.each_with_index do |line, index|
          # Keep track of context
          context_buffer << line
          context_buffer.shift if context_buffer.size > context_lines

          # Check for error indicators
          if @definition.error_line?(line) || @definition.important_line?(line)
            # Add preceding context
            result.concat(context_buffer[0...-1]) if context_buffer.size > 1

            # Add the error line
            result << line

            # Add following context
            following = lines[index + 1, context_lines] || []
            following.each do |following_line|
              break if @definition.summary_line?(following_line)
              result << following_line unless @definition.noise_line?(following_line)
            end

            context_buffer.clear
          end
        end

        result.uniq.map(&:rstrip)
      end

      # Extract all file locations from output
      def extract_all_locations(lines)
        lines.flat_map { |line| @definition.extract_locations(line) }
      end
    end
  end
end
